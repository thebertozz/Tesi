\chapter{Swift}

\section{Cenni storici}
Lo sviluppo di Swift è iniziato nel 2010 da Chris Lattner, aiutato in seguito da molti altri programmatori. Swift ha preso idee "da Objective-C, Rust, Haskell, Ruby, Python, C\#, CLU, e molti altri".Il 2 giugno 2014 l'app per il WWDC è divenuta la prima app distribuita al pubblico scritta in Swift.\\Il 3 dicembre 2015 viene lanciato il sito swift.org ed il codice sorgente del linguaggio è pubblicato con licenza Apache 2.0 sul repository GitHub dell'azienda.\\Apple resta lo sviluppatore principale e ne rende disponibile anche una versione del compilatore per Linux (Creato appositamente per Ubuntu).\\Il 13 settembre 2016, durante la WWDC 2016, Apple ha presentato la terza versione del suo linguaggio di programmazione insieme ad un'applicazione per iPad, Swift Playgrounds, che permette, tramite una grafica semplice e intuitiva, di imparare a programmare con Swift, soprattutto orientato ai più giovani.
\section{Caratteristiche}
\subsection{Sintassi}
\subsubsection{Implementazione di una classe}
In Swift, al contrario di molti altri linguaggi, non ci sono 2 file distinti per l'interfaccia e l'implementazione, ma uno solo con l'estensione .swift\\
Esempio di creazione di una nuova classe:\\
\begin{lstlisting}
class Persona { 

//dichiarazione delle properties

	var nome: String? 
	var cognome: String? 
	var eta: Int?

//costruttore personalizzato con parametri 

	init(nome: String, cognome: String, eta: Int) {
		self.nome = nome
		self.cognome = cognome
		self.eta = eta
	}

//dichiarazione dei metodi setter e getter 

	func getNome() -> String {

		return self.nome
	}

	func setNome(nome: String) {

		self.nome = nome
	}

	func getCognome() -> String {

		return self.cognome
	}

	func setCognome(cognome: String) {
	
		self.cognome = cognome
	}

	func getEta() -> Int {
	
		return eta
	}

	func setEta(eta: Int) {

		self.eta = eta
	}
}
\end{lstlisting}
\subsubsection{Dichiarazione e definizione dei metodi}
In Swift, una dichiarazione di funzione (metodo) ha la seguente sintassi: 
\begin{lstlisting}
//Nell'ordine: func nomeMetodo(nomeArg1:tipoArg1) -> tipoDiRitorno

func calcolaEta(dataDiNascita: NSDate) -> Int

\end{lstlisting}
Definizione del metodo appena dichiarato: 
\begin{lstlisting}
func calcolaEta(dataDiNascita: NSDate) -> Int

	let oggi = Date()
      
    let componentiCalendario = Calendar.current.dateComponents([.year], from: dataDiNascita, to: oggi)                             			
	
	let eta = componentiCalendario.year!
	
	return eta;
}
\end{lstlisting}
Le funzioni in Swift sono trattate come oggetti, ciò significa che una funzione può ritornare un'altra funzione: 
\begin{lstlisting}
func creaIncrementatore() -> ((Int) -> Int) {
	
	func aggiungiUno(numero: Int) -> Int {
	
		return 1 + numero 
	
	}
	
	return aggiungiUno
}

var incrementatore = creaIncrementatore()
incrementatore(7)
\end{lstlisting}
\subsubsection{Closures}
Le funzioni sono un caso speciale di "closure": il codice in una closure ha accesso a variabili e funzioni che sono disponibili nel suo scope, anche se viene eseguita in uno scope diverso. Una closure viene definita dalla sintassi \{ \}, utilizzando il separatore \"in\" per gli argomenti e il tipo di ritorno dal corpo:\\\\ 
\begin{lstlisting}
var numeri = [2,25,21,89,90]

numeri.map({
	(numero: Int) -> Int in 
	let risultato = 3 * numero 
	return risultato 
})
\end{lstlisting}
Ci sono vari modi per scrivere le closure: quando il tipo è già conosciuto, come per esempio in una callback per un delegate, si possono omettere i tipi dei parametri, il tipo di ritorno o entrambi nel caso in cui ci sia un singolo statement, in quanto la closure ritorna implicitamente il valore di ritorno:
\begin{lstlisting}
let numeriInMap = numeri.map({ numero in 3 * numero })
\end{lstlisting}
Ci si può riferire ai parametri per numero invece che per nome, approccio utile specialmente in closure che richiedono poco codice; una closure passata come ultimo argomento di una funzione può essere scritta immediatamente dopo le parentesi, e se quest'ultima è l'unico argomento della funzione stessa si possono omettere le parentesi tonde: 
\begin{lstlisting}
//ordino i numeri in modo crescente

let numeriOrdinati = numeri.sorted { $0 > $1 }
\end{lstlisting}
\subsection{Gestione della memoria}
TODO
\subsection{Compilatore}
TODO
\subsection{Utilizzo in iOS e frameworks Cocoa}
TODO