\chapter{Swift}

\section{Cenni storici}
Lo sviluppo di Swift è iniziato nel 2010 da Chris Lattner, aiutato in seguito da molti altri programmatori. Swift ha preso idee "da Objective-C, Rust, Haskell, Ruby, Python, C\#, CLU, e molti altri".Il 2 giugno 2014 l'app per il WWDC è divenuta la prima app distribuita al pubblico scritta in Swift.\\Il 3 dicembre 2015 viene lanciato il sito swift.org ed il codice sorgente del linguaggio è pubblicato con licenza Apache 2.0 sul repository GitHub dell'azienda.\\Apple resta lo sviluppatore principale e ne rende disponibile anche una versione del compilatore per Linux (Creato appositamente per Ubuntu).\\Il 13 settembre 2016, durante la WWDC 2016, Apple ha presentato la terza versione del suo linguaggio di programmazione insieme ad un'applicazione per iPad, Swift Playgrounds, che permette, tramite una grafica semplice e intuitiva, di imparare a programmare con Swift, soprattutto orientato ai più giovani.
\section{Caratteristiche}
\subsection{Sintassi}
\subsubsection{Implementazione di una classe}
In Swift, al contrario di molti altri linguaggi, non ci sono 2 file distinti per l'interfaccia e l'implementazione, ma uno solo con l'estensione .swift\\
Esempio di creazione di una nuova classe:\\
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
class Persona { 

//dichiarazione delle properties

	var nome: String? 
	var cognome: String? 
	var eta: Int?

//costruttore personalizzato con parametri 

	init(nome: String, cognome: String, eta: Int) {
		self.nome = nome
		self.cognome = cognome
		self.eta = eta
	}

//dichiarazione dei metodi setter e getter 

	func getNome() -> String {

		return self.nome
	}

	func setNome(nome: String) {

		self.nome = nome
	}

	func getCognome() -> String {

		return self.cognome
	}

	func setCognome(cognome: String) {
	
		self.cognome = cognome
	}

	func getEta() -> Int {
	
		return eta
	}

	func setEta(eta: Int) {

		self.eta = eta
	}
}
\end{lstlisting}
\subsubsection{Dichiarazione e definizione dei metodi}
In Swift, una dichiarazione di funzione (metodo) ha la seguente sintassi: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
//Nell'ordine: func nomeMetodo(nomeArg1:tipoArg1) -> tipoDiRitorno

func calcolaEta(dataDiNascita: NSDate) -> Int

\end{lstlisting}
Definizione del metodo appena dichiarato: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
func calcolaEta(dataDiNascita: NSDate) -> Int

	let oggi = Date()
      
    let componentiCalendario = Calendar.current.dateComponents([.year], from: dataDiNascita, to: oggi)                             			
	
	let eta = componentiCalendario.year!
	
	return eta;
}
\end{lstlisting}
Le funzioni in Swift sono trattate come oggetti, ciò significa che una funzione può ritornare un'altra funzione: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
func creaIncrementatore() -> ((Int) -> Int) {
	
	func aggiungiUno(numero: Int) -> Int {
	
		return 1 + numero 
	
	}
	
	return aggiungiUno
}

var incrementatore = creaIncrementatore()
incrementatore(7)
\end{lstlisting}
\subsubsection{Closures}
Le funzioni sono un caso speciale di "closure": il codice in una closure ha accesso a variabili e funzioni che sono disponibili nel suo scope, anche se viene eseguita in uno scope diverso. Una closure viene definita dalla sintassi \{ \}, utilizzando il separatore \"in\" per gli argomenti e il tipo di ritorno dal corpo:\\\\ 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
var numeri = [2,25,21,89,90]

numeri.map({
	(numero: Int) -> Int in 
	let risultato = 3 * numero 
	return risultato 
})
\end{lstlisting}
Ci sono vari modi per scrivere le closure: quando il tipo è già conosciuto, come per esempio in una callback per un delegate, si possono omettere i tipi dei parametri, il tipo di ritorno o entrambi nel caso in cui ci sia un singolo statement, in quanto la closure ritorna implicitamente il valore di ritorno:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
let numeriInMap = numeri.map({ numero in 3 * numero })
\end{lstlisting}
Ci si può riferire ai parametri per numero invece che per nome, approccio utile specialmente in closure che richiedono poco codice; una closure passata come ultimo argomento di una funzione può essere scritta immediatamente dopo le parentesi, e se quest'ultima è l'unico argomento della funzione stessa si possono omettere le parentesi tonde: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
//ordino i numeri in modo crescente

let numeriOrdinati = numeri.sorted { $0 > $1 }
\end{lstlisting}
\subsubsection{Enumerazioni}
La sintassi enum è utilizzata per dichiarare le enumerazioni in Swift. La particolarità rispetto ad Objective-C è che quest'ultime possono contenere metodi:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
enum TipologieDiCase {

	case condominio, villa, indipendente, attico
	
	func descrizione() -> String {
	
		switch self {
	
		case .condominio:
			return "Condominio"
		case .villa :
			return "Villa"
		case .indipendente:
			return "Casa indipendente"
		case .attico
			return "Attico"
		default: 
			return String(self.rawValue)
		
		}
	}
}

let villa = TipologieDiCase.villa
let descrizioneVilla = villa.descrizione()
\end{lstlisting}
\subsubsection{Protocolli ed estensioni}
Un protocollo definisce un'interfaccia di metodi, variabili ed altri eventuali requisiti che definiscono una particolare funzionalità. Quest'ultimo può essere quindi adottato da una classe, struct o enum che ne forniranno l'implementazione:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
protocol ProtocolloDiNavigazioni {
	
	func navigaAlleImpostazioni(sender: CollectionView) 
	func navigaAlDettaglioEvento(sender: UICollectionView)
}

class MenuPrincipale: UICollectionViewController, UICollectionViewDelegateFlowLayout: ProtocolloDiNavigazioni {

	override func viewDidLoad() {
        super.viewDidLoad()
		collectionView?.delegate = self
		collectionView?.dataSource = self
	}
	
	...
	
	//MARK: CollectionViewDelegate 
	
	override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) {
		
		switch indexPath {
			
			case 0: 
				navigaAlleImpostazioni(self.collectionView)
			case 1:
				navigaAlDettaglioEvento(self.collectionView)
		}
	}	
		
	//MARK: Implementazione del protocollo 
		
	func navigaAlleImpostazioni(sender: UICollectionView) {
        
        appDelegate.gotoSettingsVC()
    }
    
    func navigaAlDettaglioEvento(sender: UICollectionView) {
        
        appDelegate.gotoEventDetailVC()
    }
}
\end{lstlisting}
Le estensioni sono invece un modo per aggiungere funzionalità ad un tipo eisstente, come nuovi metodi e computed properties:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
//Estensione che aggiunge un effetto di blur ad una imageView

extension UIImageView
{
    func aggiungiBlur()
    {
        let blurEffect = UIBlurEffect(style: UIBlurEffectStyle.Light)
        let blurEffectView = UIVisualEffectView(effect: blurEffect)
        blurEffectView.frame = self.bounds
        self.addSubview(blurEffectView)
    }
}

let containerImmagine = UIImageView()
containerImmagine.image = UIImage(named: "beer2beerlogo.jpg")
containerImmagine.aggiungiBlur()
\end{lstlisting}
\subsubsection{Gestione degli errori}
Gli errori vengono rappresentati utilizzando qualsiasi tipo che si conformi al protocollo Error; la parola chiave throws viene utilizzata per indicare che una funzione può ritornare un errore, utilizzando la parola chiave throw. Se si lancia un errore dall'interno di una funzione, quest'ultima ritorna immediatamente e l'errore viene gestito dalla funzione chiamante:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
enum ErroriStampante: Error {

	case cartaEsaurita
	case inchiostroEsaurito
	case cassettoChiuso
	
}

func invia(lavoro: Int, allaStampante nomeStampante: Stringa) throws -> String {
	if nomeStampante = "Rusty old printer" {
		
		throw ErroriStampante.cassettoChiuso
	}

	return "Lavoro inviato alla stampante"
}

	do {
	
	let rispostaStampante = try invia(lavoro: 2303, allaStampante: "Sala meeting")
	
	print(rispostaStampante)
	
	} catch {
		
		print(error)
	}
	
\end{lstlisting}
Si possono inoltre utilizzare più blocchi catch per gestire errori specifici:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
	do {
	
		let rispostaStampante = try invia(lavoro: 2303, allaStampante: "Sala 	meeting")
	
		print(rispostaStampante)
	
		} catch ErroriStampante.cassettoChiuso {
		
			print("Aprire il cassetto")
		}
\end{lstlisting}
Un altro modo per gestire gli errori è quello di utilizzare la parola chiave try? per convertire il risultato in un tipo optional: se la funzione lancia un errore, questo specifico errore è ignorato e la funzione ritorna nil; alternativamente il risultato è un optional contenente il valore ritornato dalla funzione:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
let foglioStampato = try? invia(lavoro: 1984, allaStampante: "Sala meeting")
let erroreDiStampa = try? invia(lavoro: 1948, allaStampante: "Rusty old printer")
\end{lstlisting}
\subsubsection{Generics}
Una funzione generica, più comunemente chiamata template, è così dichiarata:
\lstset{language=[Objective]C, breakindent=40pt, breaklines} 
\begin{lstlisting}
func creaArray<Elemento>(ripeti	elemento: Elemento, numeroDiVolte: Int) -> [Elemento] {

	var risultato = [Elemento]()
	
	for _ in 0..< numeroDiVolte {
		
		risultato.append(elemento)
	}
	
	return risultato
}

//chiamata alla funzione 

creaArray(ripeti: "Tick tock", numeroDiVolte: 3)
\end{lstlisting}
Si possono creare generics di funzioni o di classi, enumerazioni e struct:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
//Reimplementazione del tipo optional della libreria standard di Swift

enum OptionalValue<Wrapped> {

	case none 
	case some(Wrapped)
}

var possibileIntero: OptionalValue<Int> = .none
possibileIntero = .some(100)
\end{lstlisting}
Si utilizza la parola chiave where prima del corpo per indicare una lista di requisiti, per esempio per indicare che il tipo deve conformarsi ad un protocol, per richiedere che due tipi siano uguali o per indicare che una classe deve avere una particolare superclasse: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
func elementiComuni<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool {
	
	where T.Iterator.Element: Equatable,
		  T.Iterator.Element == U.Iterator.Element {
		  
		  	for lhsItem in lhs {
		  	
		  		for rhsItem in rhs {
		  		
		  			if lhsItem == rhsItem {
		  				
		  				return true
		  			}
		  		}
		  	}
		  }
		  
		  return false
}

//chiamata alla funzione 

elementiComuni([1,2,3], [3])
\end{lstlisting}
\subsubsection{Tuples}
Feature non presente in Objective-C, le tuple raggruppano più valori (di un tipo qualsiasi o tipi differenti) in un singolo valore composto. Per esempio, potremmo descrivere lo status code 404 dell'HTTP con una tupla in questo modo:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
let errore404http = (404, "Not found")
\end{lstlisting}
La tupla (404, "Not found") raggruppa insieme un tipo Int e uno String; si può creare qualsiasi permutazione di tipi. Per ottenere i singoli valori da una tupla, quest'ultima deve essere scomposta:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
let (statusCode, statusMessage) = errore404http
\end{lstlisting}
Questo particolare tipo è utile come valore di ritorno dalle funzioni, per esempio una funzione che ha il compito di caricare una pagina web potrebbe usare la tupla sopra descritta per indicare il successo o il fallimento del caricamento, fornendo più informazioni rispetto ad un valore di ritorno singolo di un singolo tipo. 
\subsubsection{Optionals}
Questo tipo è un pilastro portante di Swift, in quanto viene utilizzato  in tutti i casi in cui il valore di ritorno potrebbe essere nullo (nil). La logica di funzionamento è la seguente: o c'è un tipo di ritorno, e quindi si utilizza l'unwrapping per accedere al valore, o non c'è valore alcuno.\\
Il concetto di optional non esiste in C o Objective-C. Ciò che ci si avvicina di più è l'abilità di ritornare nil da un metodo che altrimenti ritornerebbe un oggetto, con nil a significare l'assenza di un oggetto valido.\\Questo però funziona solamente per gli oggetti (non structs, tipi C  o enumerativi); per questi i metodi Objective-C ritornano solamente un valore speciale (come per esempio NSNotFound). Questo implica che il chiamante dei metodi sappia che c'è uno speciale valore da verificare, l'approccio di Swift permette invece di indicare l'assenza di qualsiasi valore in assoluto, senza la necessità per speciali costanti.\\
In questo esempio vediamo come gli optional possono essere utilizzati per gestire il caso di assenza di valore. Il tipo Int di Swift ha un costruttore che prova a convertire una String  in un valore di tipo Int; questa conversione può fallire e quindi viene utilizzato un tipo optional:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
let possibileNumero = "123"
let numeroConvertito = Int(possibileNumero)
//numeroConvertito e' di tipo Int?, che si legge come "optional Int"
\end{lstlisting} 
Poichè il costruttore può fallire, questi ritorna un tipo optional Int, scritto Int?. Il punto di domanda indica che il valore contiene un tipo optional, il che significa che potrebbe contenere un valore Int, o nessun valore.\\
Utilizzando la speciale parola chiave nil, si indica che un tipo optional non ha valore alcuno. nil non può essere utilizzato con constanti e variabili non optional.
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
var codiceRispostaServer: Int? = nil
\end{lstlisting}
Se si crea una variabile optional, alla quale non si assegna alcun valore, a quest'ultima viene automaticamente assegnato nil.\\Il nil di Swift non è però equivalente a quello di Objective-C: in quest ultimo, nil è un puntatore ad un oggetto che non esiste, in Swift non è invece un puntatore, è l'assenza di valore alcuno. Optionals di qualunque tipo possono essere settati a nil, non solamente oggetti.\\
Per verificare la presenza di valore in un tipo optional è possibile usare lo statement if in questo modo: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
if numeroConvertito != nil {

	//numero convertito contiene un valore
}
\end{lstlisting}
Alternativamente è possibile utilizzare il simbolo !, letto come \"forced unwrapping\"  del tipo optional; questo approccio è rischioso e porta spesso ad errori in runtime. 
\subsection{Gestione della memoria}
TODO
\subsection{Compilatore}
TODO
\subsection{Utilizzo in iOS e frameworks Cocoa}
TODO
