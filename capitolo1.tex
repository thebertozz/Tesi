\chapter{Objective-C}
Creato agli inizi degli anni '80, Objective-C ha guadagnato la sua popolarità come il linguaggio principale per il sistema operativo NEXTSTEP.\\
Quando nel 1996 Next venne acquisita da Apple il loro sistema operativo divenne la base del nuovo Mac OS, rendendo così questo linguaggio la chiave per lo sviluppo negli anni a venire. Per molti anni Objective-C è rimasto l’unico linguaggio per lo sviluppo su piattaforme Mac ed iOS.\\
La sua implementazione è basata sul linguaggio C con l'aggiunta di caratteristiche di programmazione orientata agli oggetti ed un runtime dinamico.
\section{Caratteristiche del linguaggio}
Questo capitolo descrive le funzionalità che il linguaggio aggiunge allo standard C. 
\subsection{Sintassi}
\subsubsection{Implementazione di una classe, i file .h e .m}
L'implementazione di una classe avviene attraverso due file distinti:
\begin{itemize}
\item Un file con estensione .h, che conterrà la dichiarazione dell'interfaccia di classe, i metodi e le properties pubbliche.
\item Un file con estensione .m, che conterrà l'implementazione della classe, la definizione di metodi e properties private; in questo file inoltre saranno definiti i metodi e le variabili d'istanza private.
\end{itemize}
\newpage
Esempio di file header (.h) di una classe:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
#import <Foundation/Foundation.h>

@interface Persona: NSObject ()

//costruttore personalizzato con parametri 

- (id)initConNome:(NSString *)unNome
      cognome:(NSString *)unCognome;

// dichiarazione delle properties private 

@private
	NSString *_nome;
	NSString *_cognome;
	int _eta; 
}

// dichiarazione dei metodi getter e setter

- (NSString *)nome;
- (void)setNome:(NSString *)nome;
- (NSString *)cognome;
- (void)setCognome:(NSString *)cognome;
- (int)eta;
- (void)setEta:(int)eta;

@end
\end{lstlisting}
\bigskip
\bigskip
\bigskip
Esempio di file di implementazione (.m) di una classe:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
#import "Persona.h" 

@implementation Persona

//implementazione della classe dichiarata in Persona.h

- (id)initConNome:(NSString *)unNome
      cognome:(NSString *)unCognome {
    
    if( self = [super init] )
    {
        _nome = unNome;
        _cognome = unCognome;
    }
    
    return self;
}
 
-(NSString *) nome {
	return _nome
}

-(NSString *) cognome {
	return _cognome
}

-(int) eta {
	return _eta
}

-(void)setNome:(NSString *)nome {
	_nome = nome;
}

-(void)setCognome:(NSString *)cognome {
	_cognome = cognome;
}

-(void)setEta:(int)eta {
	_eta = eta;
}
@end
\end{lstlisting}
\bigskip
\bigskip
\bigskip
Attraverso la parola chiave @property è anche possibile dare direttiva al compilatore di definire i setter e i getter:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
//come dichiarati in Persona.h
- (NSString *)nome;
- (void)setNome:(NSString *)nome;

//con property diventa
@property NSString * nome;
\end{lstlisting}
\newpage
Inoltre, attraverso la parola chiave @synthesize, è possibile indicare al compilatore di implementare i setter e i getter di una property che sia stata definita precedentemente:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
//come dichiarati in Persona.m

-(NSString *) nome {
	return _nome
}

-(void)setNome:(NSString *)nome {
	_nome = nome;
}
//con synthesize diventa:

@synthesize nome = _nome; 
\end{lstlisting}
Le properties permettono di accedere ai getter e ai setter utilizzando la notazione puntata, per una maggiore leggibilità del codice:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
//senza properties: 

int eta = [persona eta]; 
[persona setEta:22]; 

//con properties: 

int eta = persona.eta;
persona.eta = 22;
\end{lstlisting}
\newpage
\subsubsection{Dichiarazione e definizione dei metodi}
Come visto per la definizione dei setter, una dichiarazione di funzione (metodo) ha la seguente sintassi: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
//Nell'ordine: (tipoDiRitorno) nomeMetodo:(tipoArg1)nomeArg1;

- (NSInteger)calcolaEta:(NSDate)dataDiNascita;
\end{lstlisting}
Definizione del metodo appena dichiarato: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
- (NSInteger)calcolaEta:(NSDate)dataDiNascita {

	NSDate* oggi = [NSDate date];
	NSDateComponents* componentiCalendario = [[NSCalendar currentCalendar] 
                                   			components:NSCalendarUnitYear 
                                   			fromDate:dataDiNascita
                                   			toDate:oggi
                                   			options:0];
	
	NSInteger eta = [componentiCalendario year];
	
	return eta;
}
\end{lstlisting}
\subsubsection{Invio dei messaggi}
In Objective-C, a differenza della maggior parte degli altri linguaggi, un metodo non viene chiamato direttamente, ma si invia un messaggio all'oggetto stesso: 
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
[persona calcolaEta:dataDiNascita];
\end{lstlisting}
Questo è reso possibile dal runtime del linguaggio che, tramite una lista, tiene traccia di tutti i metodi e funzioni che conosce. Ogni elemento della lista è composto da due campi: il nome del metodo (conosciuto come il selector dello stesso) e la sua locazione in memoria.
\\Durante la fase di compilazione del codice sorgente, quando vi è la chiamata di un metodo, il compilatore sostituisce il frammento di codice nel seguente modo:
\lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
[persona calcolaEta:dataDiNascita];
\end{lstlisting}
in \lstset{language=[Objective]C, breakindent=40pt, breaklines}
\begin{lstlisting}
objc_msgSend(persona, @selector(calcolaEta:),dataDiNascita);
\end{lstlisting}
\bigskip
\bigskip
La funzione objc\_msgSend() opera tramite un lookup dinamico: conoscendo il nome del metodo da ricercare scorre la lista per verificare la sua effettiva presenza e, in caso affermativo, lo esegue.\\ 
Questo comportamento ha caratteristiche particolari: potremmo far puntare un certo selettore A, che prima puntava al codice per A, ad un codice per un certo B.\\ 
Lo svantaggio è che il tempo di esecuzione è leggermente maggiore di una chiamata diretta alla parte di codice; si tratta comunque di nanosecondi di differenza.\\
\\Inoltre il runtime, prima di inviare il messaggio, richiede all’oggetto se il metodo è riconosciuto dallo stesso. Questo significa che l’oggetto può decidere se accettare il messaggio (è anche per questo che si possono inviare messaggi a nil), inoltrarlo ad un oggetto differente, decidere di eseguire codice differente per un metodo specifico.\\Più in dettaglio, quando inviamo un messaggio ad un oggetto, non abbiamo garanzie sul fatto che:\\ \\-Il metodo che andiamo a chiamare non sia necessariamente quello che verrà effettivamente chiamato\\\\-L’oggetto che riceverà il messaggio non sarà necessariamente quello che vogliamo che risponda.
\subsection{Compilatore}
L'IDE di Apple, Xcode, utilizza clang. Quest'ultimo è un compilatore front end per C, C++, Objective-C, Objective-C++, OpenMP, OpenCL e CUDA, basato sul compilatore LLVM (Low Level Virtual Machine).\\
LLVM in origine doveva utilizzare il front end di GCC, ma dopo aver riscontrato problemi di integrazione e di sviluppo l'azienda ha deciso di crearne iternamente uno proprio, clang appunto, reso open-source nel Giugno 2007. 
\subsection{Utilizzo in iOS e frameworks Cocoa}
Il linguaggio principale di tutti i frameworks (quali CoreOS, Foundation, CocoaTouch) di iOS e MacOS è ancora Objective-C come dal principio, in quanto Swift non ha ancora raggiunto un livello di maturità tale per essere impiegato per questi scopi (la versione 3 del linguaggio non ha ancora ABI stabili e la sintassi è ancora in corso di modifiche).L'intenzione di Apple è quella di mantenere e migliorare i due linguaggi parallelamente per ancora molto tempo.